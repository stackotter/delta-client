// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: BlockRegistry.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum ProtobufBlockComputedTintType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case water // = 0
  case foliage // = 1
  case grass // = 2
  case sugarCane // = 3
  case lilyPad // = 4
  case shearingDoublePlant // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .water
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .water
    case 1: self = .foliage
    case 2: self = .grass
    case 3: self = .sugarCane
    case 4: self = .lilyPad
    case 5: self = .shearingDoublePlant
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .water: return 0
    case .foliage: return 1
    case .grass: return 2
    case .sugarCane: return 3
    case .lilyPad: return 4
    case .shearingDoublePlant: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ProtobufBlockComputedTintType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [ProtobufBlockComputedTintType] = [
    .water,
    .foliage,
    .grass,
    .sugarCane,
    .lilyPad,
    .shearingDoublePlant,
  ]
}

#endif  // swift(>=4.2)

public enum ProtobufBlockOffset: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case xyz // = 0
  case xz // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .xyz
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .xyz
    case 1: self = .xz
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .xyz: return 0
    case .xz: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ProtobufBlockOffset: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [ProtobufBlockOffset] = [
    .xyz,
    .xz,
  ]
}

#endif  // swift(>=4.2)

public struct ProtobufBlockFluidState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fluidID: Int32 = 0

  public var height: Int32 = 0

  public var isWaterlogged: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ProtobufBlockTintRGBColor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var r: Int32 = 0

  public var g: Int32 = 0

  public var b: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ProtobufBlockTint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var computedTint: ProtobufBlockComputedTintType {
    get {return _computedTint ?? .water}
    set {_computedTint = newValue}
  }
  /// Returns true if `computedTint` has been explicitly set.
  public var hasComputedTint: Bool {return self._computedTint != nil}
  /// Clears the value of `computedTint`. Subsequent reads from it will return its default value.
  public mutating func clearComputedTint() {self._computedTint = nil}

  public var hardcodedTint: ProtobufBlockTintRGBColor {
    get {return _hardcodedTint ?? ProtobufBlockTintRGBColor()}
    set {_hardcodedTint = newValue}
  }
  /// Returns true if `hardcodedTint` has been explicitly set.
  public var hasHardcodedTint: Bool {return self._hardcodedTint != nil}
  /// Clears the value of `hardcodedTint`. Subsequent reads from it will return its default value.
  public mutating func clearHardcodedTint() {self._hardcodedTint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _computedTint: ProtobufBlockComputedTintType? = nil
  fileprivate var _hardcodedTint: ProtobufBlockTintRGBColor? = nil
}

public struct ProtobufBlockPhysicalMaterial {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var explosionResistance: Double = 0

  public var slipperiness: Double = 0

  public var velocityMultiplier: Double = 0

  public var jumpVelocityMultiplier: Double = 0

  public var requiresTool: Bool = false

  public var hardness: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ProtobufBlockLightMaterial {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var isTranslucent: Bool = false

  public var opacity: Int32 = 0

  public var luminance: Int32 = 0

  public var isConditionallyTransparent: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ProtobufBlockSoundMaterial {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var volume: Double = 0

  public var pitch: Double = 0

  public var breakSound: Int32 = 0

  public var stepSound: Int32 = 0

  public var placeSound: Int32 = 0

  public var hitSound: Int32 = 0

  public var fallSound: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ProtobufBlockOcclusionShapeIds {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ids: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ProtobufBlockIsSturdy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var values: [Bool] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ProtobufVec3f {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var x: Float = 0

  public var y: Float = 0

  public var z: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ProtobufAABB {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var position: ProtobufVec3f {
    get {return _position ?? ProtobufVec3f()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  public var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  public mutating func clearPosition() {self._position = nil}

  public var size: ProtobufVec3f {
    get {return _size ?? ProtobufVec3f()}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  public var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  public mutating func clearSize() {self._size = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _position: ProtobufVec3f? = nil
  fileprivate var _size: ProtobufVec3f? = nil
}

public struct ProtobufBlockShape {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var isDynamic: Bool = false

  public var isLarge: Bool = false

  public var collisionShape: [ProtobufAABB] = []

  public var outlineShape: [ProtobufAABB] = []

  public var occlusionShapeIds: ProtobufBlockOcclusionShapeIds {
    get {return _occlusionShapeIds ?? ProtobufBlockOcclusionShapeIds()}
    set {_occlusionShapeIds = newValue}
  }
  /// Returns true if `occlusionShapeIds` has been explicitly set.
  public var hasOcclusionShapeIds: Bool {return self._occlusionShapeIds != nil}
  /// Clears the value of `occlusionShapeIds`. Subsequent reads from it will return its default value.
  public mutating func clearOcclusionShapeIds() {self._occlusionShapeIds = nil}

  public var isSturdy: ProtobufBlockIsSturdy {
    get {return _isSturdy ?? ProtobufBlockIsSturdy()}
    set {_isSturdy = newValue}
  }
  /// Returns true if `isSturdy` has been explicitly set.
  public var hasIsSturdy: Bool {return self._isSturdy != nil}
  /// Clears the value of `isSturdy`. Subsequent reads from it will return its default value.
  public mutating func clearIsSturdy() {self._isSturdy = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _occlusionShapeIds: ProtobufBlockOcclusionShapeIds? = nil
  fileprivate var _isSturdy: ProtobufBlockIsSturdy? = nil
}

public struct ProtobufBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var vanillaParentBlockID: Int32 {
    get {return _storage._vanillaParentBlockID}
    set {_uniqueStorage()._vanillaParentBlockID = newValue}
  }

  public var identifierNamespace: String {
    get {return _storage._identifierNamespace}
    set {_uniqueStorage()._identifierNamespace = newValue}
  }

  public var identifierName: String {
    get {return _storage._identifierName}
    set {_uniqueStorage()._identifierName = newValue}
  }

  public var className: String {
    get {return _storage._className}
    set {_uniqueStorage()._className = newValue}
  }

  public var fluidState: ProtobufBlockFluidState {
    get {return _storage._fluidState ?? ProtobufBlockFluidState()}
    set {_uniqueStorage()._fluidState = newValue}
  }
  /// Returns true if `fluidState` has been explicitly set.
  public var hasFluidState: Bool {return _storage._fluidState != nil}
  /// Clears the value of `fluidState`. Subsequent reads from it will return its default value.
  public mutating func clearFluidState() {_uniqueStorage()._fluidState = nil}

  public var tint: ProtobufBlockTint {
    get {return _storage._tint ?? ProtobufBlockTint()}
    set {_uniqueStorage()._tint = newValue}
  }
  /// Returns true if `tint` has been explicitly set.
  public var hasTint: Bool {return _storage._tint != nil}
  /// Clears the value of `tint`. Subsequent reads from it will return its default value.
  public mutating func clearTint() {_uniqueStorage()._tint = nil}

  public var offset: ProtobufBlockOffset {
    get {return _storage._offset ?? .xyz}
    set {_uniqueStorage()._offset = newValue}
  }
  /// Returns true if `offset` has been explicitly set.
  public var hasOffset: Bool {return _storage._offset != nil}
  /// Clears the value of `offset`. Subsequent reads from it will return its default value.
  public mutating func clearOffset() {_uniqueStorage()._offset = nil}

  public var material: ProtobufBlockPhysicalMaterial {
    get {return _storage._material ?? ProtobufBlockPhysicalMaterial()}
    set {_uniqueStorage()._material = newValue}
  }
  /// Returns true if `material` has been explicitly set.
  public var hasMaterial: Bool {return _storage._material != nil}
  /// Clears the value of `material`. Subsequent reads from it will return its default value.
  public mutating func clearMaterial() {_uniqueStorage()._material = nil}

  public var lightMaterial: ProtobufBlockLightMaterial {
    get {return _storage._lightMaterial ?? ProtobufBlockLightMaterial()}
    set {_uniqueStorage()._lightMaterial = newValue}
  }
  /// Returns true if `lightMaterial` has been explicitly set.
  public var hasLightMaterial: Bool {return _storage._lightMaterial != nil}
  /// Clears the value of `lightMaterial`. Subsequent reads from it will return its default value.
  public mutating func clearLightMaterial() {_uniqueStorage()._lightMaterial = nil}

  public var soundMaterial: ProtobufBlockSoundMaterial {
    get {return _storage._soundMaterial ?? ProtobufBlockSoundMaterial()}
    set {_uniqueStorage()._soundMaterial = newValue}
  }
  /// Returns true if `soundMaterial` has been explicitly set.
  public var hasSoundMaterial: Bool {return _storage._soundMaterial != nil}
  /// Clears the value of `soundMaterial`. Subsequent reads from it will return its default value.
  public mutating func clearSoundMaterial() {_uniqueStorage()._soundMaterial = nil}

  public var shape: ProtobufBlockShape {
    get {return _storage._shape ?? ProtobufBlockShape()}
    set {_uniqueStorage()._shape = newValue}
  }
  /// Returns true if `shape` has been explicitly set.
  public var hasShape: Bool {return _storage._shape != nil}
  /// Clears the value of `shape`. Subsequent reads from it will return its default value.
  public mutating func clearShape() {_uniqueStorage()._shape = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ProtobufBlockModelPartDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var identifierNamespace: String = String()

  public var identifierName: String = String()

  public var xRotationDegrees: Int32 = 0

  public var yRotationDegrees: Int32 = 0

  public var uvLock: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ProtobufBlockModelVariantDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var parts: [ProtobufBlockModelPartDescriptor] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ProtobufBlockModelDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var variants: [ProtobufBlockModelVariantDescriptor] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ProtobufBlockRegistry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var blocks: [ProtobufBlock] = []

  public var renderDescriptors: [ProtobufBlockModelDescriptor] = []

  public var selfCullingBlocks: [Int32] = []

  public var airBlocks: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension ProtobufBlockComputedTintType: @unchecked Sendable {}
extension ProtobufBlockOffset: @unchecked Sendable {}
extension ProtobufBlockFluidState: @unchecked Sendable {}
extension ProtobufBlockTintRGBColor: @unchecked Sendable {}
extension ProtobufBlockTint: @unchecked Sendable {}
extension ProtobufBlockPhysicalMaterial: @unchecked Sendable {}
extension ProtobufBlockLightMaterial: @unchecked Sendable {}
extension ProtobufBlockSoundMaterial: @unchecked Sendable {}
extension ProtobufBlockOcclusionShapeIds: @unchecked Sendable {}
extension ProtobufBlockIsSturdy: @unchecked Sendable {}
extension ProtobufVec3f: @unchecked Sendable {}
extension ProtobufAABB: @unchecked Sendable {}
extension ProtobufBlockShape: @unchecked Sendable {}
extension ProtobufBlock: @unchecked Sendable {}
extension ProtobufBlockModelPartDescriptor: @unchecked Sendable {}
extension ProtobufBlockModelVariantDescriptor: @unchecked Sendable {}
extension ProtobufBlockModelDescriptor: @unchecked Sendable {}
extension ProtobufBlockRegistry: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension ProtobufBlockComputedTintType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WATER"),
    1: .same(proto: "FOLIAGE"),
    2: .same(proto: "GRASS"),
    3: .same(proto: "SUGAR_CANE"),
    4: .same(proto: "LILY_PAD"),
    5: .same(proto: "SHEARING_DOUBLE_PLANT"),
  ]
}

extension ProtobufBlockOffset: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "XYZ"),
    1: .same(proto: "XZ"),
  ]
}

extension ProtobufBlockFluidState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ProtobufBlockFluidState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fluid_id"),
    2: .same(proto: "height"),
    3: .standard(proto: "is_waterlogged"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.fluidID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isWaterlogged) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fluidID != 0 {
      try visitor.visitSingularInt32Field(value: self.fluidID, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 2)
    }
    if self.isWaterlogged != false {
      try visitor.visitSingularBoolField(value: self.isWaterlogged, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtobufBlockFluidState, rhs: ProtobufBlockFluidState) -> Bool {
    if lhs.fluidID != rhs.fluidID {return false}
    if lhs.height != rhs.height {return false}
    if lhs.isWaterlogged != rhs.isWaterlogged {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufBlockTintRGBColor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ProtobufBlockTintRGBColor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "r"),
    2: .same(proto: "g"),
    4: .same(proto: "b"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.r) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.g) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.b) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.r != 0 {
      try visitor.visitSingularInt32Field(value: self.r, fieldNumber: 1)
    }
    if self.g != 0 {
      try visitor.visitSingularInt32Field(value: self.g, fieldNumber: 2)
    }
    if self.b != 0 {
      try visitor.visitSingularInt32Field(value: self.b, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtobufBlockTintRGBColor, rhs: ProtobufBlockTintRGBColor) -> Bool {
    if lhs.r != rhs.r {return false}
    if lhs.g != rhs.g {return false}
    if lhs.b != rhs.b {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufBlockTint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ProtobufBlockTint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "computed_tint"),
    2: .standard(proto: "hardcoded_tint"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._computedTint) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._hardcodedTint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._computedTint {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._hardcodedTint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtobufBlockTint, rhs: ProtobufBlockTint) -> Bool {
    if lhs._computedTint != rhs._computedTint {return false}
    if lhs._hardcodedTint != rhs._hardcodedTint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufBlockPhysicalMaterial: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ProtobufBlockPhysicalMaterial"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "explosion_resistance"),
    2: .same(proto: "slipperiness"),
    3: .standard(proto: "velocity_multiplier"),
    4: .standard(proto: "jump_velocity_multiplier"),
    5: .standard(proto: "requires_tool"),
    6: .same(proto: "hardness"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.explosionResistance) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.slipperiness) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.velocityMultiplier) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.jumpVelocityMultiplier) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.requiresTool) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.hardness) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.explosionResistance != 0 {
      try visitor.visitSingularDoubleField(value: self.explosionResistance, fieldNumber: 1)
    }
    if self.slipperiness != 0 {
      try visitor.visitSingularDoubleField(value: self.slipperiness, fieldNumber: 2)
    }
    if self.velocityMultiplier != 0 {
      try visitor.visitSingularDoubleField(value: self.velocityMultiplier, fieldNumber: 3)
    }
    if self.jumpVelocityMultiplier != 0 {
      try visitor.visitSingularDoubleField(value: self.jumpVelocityMultiplier, fieldNumber: 4)
    }
    if self.requiresTool != false {
      try visitor.visitSingularBoolField(value: self.requiresTool, fieldNumber: 5)
    }
    if self.hardness != 0 {
      try visitor.visitSingularDoubleField(value: self.hardness, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtobufBlockPhysicalMaterial, rhs: ProtobufBlockPhysicalMaterial) -> Bool {
    if lhs.explosionResistance != rhs.explosionResistance {return false}
    if lhs.slipperiness != rhs.slipperiness {return false}
    if lhs.velocityMultiplier != rhs.velocityMultiplier {return false}
    if lhs.jumpVelocityMultiplier != rhs.jumpVelocityMultiplier {return false}
    if lhs.requiresTool != rhs.requiresTool {return false}
    if lhs.hardness != rhs.hardness {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufBlockLightMaterial: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ProtobufBlockLightMaterial"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_translucent"),
    2: .same(proto: "opacity"),
    3: .same(proto: "luminance"),
    4: .standard(proto: "is_conditionally_transparent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isTranslucent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.opacity) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.luminance) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isConditionallyTransparent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isTranslucent != false {
      try visitor.visitSingularBoolField(value: self.isTranslucent, fieldNumber: 1)
    }
    if self.opacity != 0 {
      try visitor.visitSingularInt32Field(value: self.opacity, fieldNumber: 2)
    }
    if self.luminance != 0 {
      try visitor.visitSingularInt32Field(value: self.luminance, fieldNumber: 3)
    }
    if self.isConditionallyTransparent != false {
      try visitor.visitSingularBoolField(value: self.isConditionallyTransparent, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtobufBlockLightMaterial, rhs: ProtobufBlockLightMaterial) -> Bool {
    if lhs.isTranslucent != rhs.isTranslucent {return false}
    if lhs.opacity != rhs.opacity {return false}
    if lhs.luminance != rhs.luminance {return false}
    if lhs.isConditionallyTransparent != rhs.isConditionallyTransparent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufBlockSoundMaterial: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ProtobufBlockSoundMaterial"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "volume"),
    2: .same(proto: "pitch"),
    3: .standard(proto: "break_sound"),
    4: .standard(proto: "step_sound"),
    5: .standard(proto: "place_sound"),
    6: .standard(proto: "hit_sound"),
    7: .standard(proto: "fall_sound"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.volume) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.pitch) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.breakSound) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.stepSound) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.placeSound) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.hitSound) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.fallSound) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.volume != 0 {
      try visitor.visitSingularDoubleField(value: self.volume, fieldNumber: 1)
    }
    if self.pitch != 0 {
      try visitor.visitSingularDoubleField(value: self.pitch, fieldNumber: 2)
    }
    if self.breakSound != 0 {
      try visitor.visitSingularInt32Field(value: self.breakSound, fieldNumber: 3)
    }
    if self.stepSound != 0 {
      try visitor.visitSingularInt32Field(value: self.stepSound, fieldNumber: 4)
    }
    if self.placeSound != 0 {
      try visitor.visitSingularInt32Field(value: self.placeSound, fieldNumber: 5)
    }
    if self.hitSound != 0 {
      try visitor.visitSingularInt32Field(value: self.hitSound, fieldNumber: 6)
    }
    if self.fallSound != 0 {
      try visitor.visitSingularInt32Field(value: self.fallSound, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtobufBlockSoundMaterial, rhs: ProtobufBlockSoundMaterial) -> Bool {
    if lhs.volume != rhs.volume {return false}
    if lhs.pitch != rhs.pitch {return false}
    if lhs.breakSound != rhs.breakSound {return false}
    if lhs.stepSound != rhs.stepSound {return false}
    if lhs.placeSound != rhs.placeSound {return false}
    if lhs.hitSound != rhs.hitSound {return false}
    if lhs.fallSound != rhs.fallSound {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufBlockOcclusionShapeIds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ProtobufBlockOcclusionShapeIds"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitPackedInt32Field(value: self.ids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtobufBlockOcclusionShapeIds, rhs: ProtobufBlockOcclusionShapeIds) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufBlockIsSturdy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ProtobufBlockIsSturdy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBoolField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitPackedBoolField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtobufBlockIsSturdy, rhs: ProtobufBlockIsSturdy) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufVec3f: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ProtobufVec3f"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.z) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    if self.z != 0 {
      try visitor.visitSingularFloatField(value: self.z, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtobufVec3f, rhs: ProtobufVec3f) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufAABB: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ProtobufAABB"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .same(proto: "size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtobufAABB, rhs: ProtobufAABB) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs._size != rhs._size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufBlockShape: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ProtobufBlockShape"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_dynamic"),
    2: .standard(proto: "is_large"),
    3: .standard(proto: "collision_shape"),
    4: .standard(proto: "outline_shape"),
    5: .standard(proto: "occlusion_shape_ids"),
    6: .standard(proto: "is_sturdy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isDynamic) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isLarge) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.collisionShape) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.outlineShape) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._occlusionShapeIds) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._isSturdy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.isDynamic != false {
      try visitor.visitSingularBoolField(value: self.isDynamic, fieldNumber: 1)
    }
    if self.isLarge != false {
      try visitor.visitSingularBoolField(value: self.isLarge, fieldNumber: 2)
    }
    if !self.collisionShape.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.collisionShape, fieldNumber: 3)
    }
    if !self.outlineShape.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outlineShape, fieldNumber: 4)
    }
    try { if let v = self._occlusionShapeIds {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._isSturdy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtobufBlockShape, rhs: ProtobufBlockShape) -> Bool {
    if lhs.isDynamic != rhs.isDynamic {return false}
    if lhs.isLarge != rhs.isLarge {return false}
    if lhs.collisionShape != rhs.collisionShape {return false}
    if lhs.outlineShape != rhs.outlineShape {return false}
    if lhs._occlusionShapeIds != rhs._occlusionShapeIds {return false}
    if lhs._isSturdy != rhs._isSturdy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ProtobufBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "vanilla_parent_block_id"),
    3: .standard(proto: "identifier_namespace"),
    4: .standard(proto: "identifier_name"),
    5: .standard(proto: "class_name"),
    6: .standard(proto: "fluid_state"),
    7: .same(proto: "tint"),
    8: .same(proto: "offset"),
    9: .same(proto: "material"),
    10: .standard(proto: "light_material"),
    11: .standard(proto: "sound_material"),
    12: .same(proto: "shape"),
  ]

  fileprivate class _StorageClass {
    var _id: Int32 = 0
    var _vanillaParentBlockID: Int32 = 0
    var _identifierNamespace: String = String()
    var _identifierName: String = String()
    var _className: String = String()
    var _fluidState: ProtobufBlockFluidState? = nil
    var _tint: ProtobufBlockTint? = nil
    var _offset: ProtobufBlockOffset? = nil
    var _material: ProtobufBlockPhysicalMaterial? = nil
    var _lightMaterial: ProtobufBlockLightMaterial? = nil
    var _soundMaterial: ProtobufBlockSoundMaterial? = nil
    var _shape: ProtobufBlockShape? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _vanillaParentBlockID = source._vanillaParentBlockID
      _identifierNamespace = source._identifierNamespace
      _identifierName = source._identifierName
      _className = source._className
      _fluidState = source._fluidState
      _tint = source._tint
      _offset = source._offset
      _material = source._material
      _lightMaterial = source._lightMaterial
      _soundMaterial = source._soundMaterial
      _shape = source._shape
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._vanillaParentBlockID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._identifierNamespace) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._identifierName) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._className) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._fluidState) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._tint) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._offset) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._material) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._lightMaterial) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._soundMaterial) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._shape) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularInt32Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._vanillaParentBlockID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._vanillaParentBlockID, fieldNumber: 2)
      }
      if !_storage._identifierNamespace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._identifierNamespace, fieldNumber: 3)
      }
      if !_storage._identifierName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._identifierName, fieldNumber: 4)
      }
      if !_storage._className.isEmpty {
        try visitor.visitSingularStringField(value: _storage._className, fieldNumber: 5)
      }
      try { if let v = _storage._fluidState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._tint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._offset {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._material {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._lightMaterial {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._soundMaterial {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._shape {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtobufBlock, rhs: ProtobufBlock) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._vanillaParentBlockID != rhs_storage._vanillaParentBlockID {return false}
        if _storage._identifierNamespace != rhs_storage._identifierNamespace {return false}
        if _storage._identifierName != rhs_storage._identifierName {return false}
        if _storage._className != rhs_storage._className {return false}
        if _storage._fluidState != rhs_storage._fluidState {return false}
        if _storage._tint != rhs_storage._tint {return false}
        if _storage._offset != rhs_storage._offset {return false}
        if _storage._material != rhs_storage._material {return false}
        if _storage._lightMaterial != rhs_storage._lightMaterial {return false}
        if _storage._soundMaterial != rhs_storage._soundMaterial {return false}
        if _storage._shape != rhs_storage._shape {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufBlockModelPartDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ProtobufBlockModelPartDescriptor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "identifier_namespace"),
    2: .standard(proto: "identifier_name"),
    3: .standard(proto: "x_rotation_degrees"),
    4: .standard(proto: "y_rotation_degrees"),
    5: .standard(proto: "uv_lock"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifierNamespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identifierName) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.xRotationDegrees) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.yRotationDegrees) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.uvLock) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifierNamespace.isEmpty {
      try visitor.visitSingularStringField(value: self.identifierNamespace, fieldNumber: 1)
    }
    if !self.identifierName.isEmpty {
      try visitor.visitSingularStringField(value: self.identifierName, fieldNumber: 2)
    }
    if self.xRotationDegrees != 0 {
      try visitor.visitSingularInt32Field(value: self.xRotationDegrees, fieldNumber: 3)
    }
    if self.yRotationDegrees != 0 {
      try visitor.visitSingularInt32Field(value: self.yRotationDegrees, fieldNumber: 4)
    }
    if self.uvLock != false {
      try visitor.visitSingularBoolField(value: self.uvLock, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtobufBlockModelPartDescriptor, rhs: ProtobufBlockModelPartDescriptor) -> Bool {
    if lhs.identifierNamespace != rhs.identifierNamespace {return false}
    if lhs.identifierName != rhs.identifierName {return false}
    if lhs.xRotationDegrees != rhs.xRotationDegrees {return false}
    if lhs.yRotationDegrees != rhs.yRotationDegrees {return false}
    if lhs.uvLock != rhs.uvLock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufBlockModelVariantDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ProtobufBlockModelVariantDescriptor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.parts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtobufBlockModelVariantDescriptor, rhs: ProtobufBlockModelVariantDescriptor) -> Bool {
    if lhs.parts != rhs.parts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufBlockModelDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ProtobufBlockModelDescriptor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "variants"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.variants) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.variants.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.variants, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtobufBlockModelDescriptor, rhs: ProtobufBlockModelDescriptor) -> Bool {
    if lhs.variants != rhs.variants {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufBlockRegistry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ProtobufBlockRegistry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blocks"),
    2: .standard(proto: "render_descriptors"),
    3: .standard(proto: "self_culling_blocks"),
    4: .standard(proto: "air_blocks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.blocks) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.renderDescriptors) }()
      case 3: try { try decoder.decodeRepeatedInt32Field(value: &self.selfCullingBlocks) }()
      case 4: try { try decoder.decodeRepeatedInt32Field(value: &self.airBlocks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 1)
    }
    if !self.renderDescriptors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.renderDescriptors, fieldNumber: 2)
    }
    if !self.selfCullingBlocks.isEmpty {
      try visitor.visitPackedInt32Field(value: self.selfCullingBlocks, fieldNumber: 3)
    }
    if !self.airBlocks.isEmpty {
      try visitor.visitPackedInt32Field(value: self.airBlocks, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtobufBlockRegistry, rhs: ProtobufBlockRegistry) -> Bool {
    if lhs.blocks != rhs.blocks {return false}
    if lhs.renderDescriptors != rhs.renderDescriptors {return false}
    if lhs.selfCullingBlocks != rhs.selfCullingBlocks {return false}
    if lhs.airBlocks != rhs.airBlocks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
